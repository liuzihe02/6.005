# Parser Generator

A *parser generator* takes a grammar as input and automatically generates source code that can parse streams of characters using that grammar.

The generated code is a *parser* , which typically produces a *parse tree* , showing how grammar productions are expanded into a sentence that matches the character sequence. The root of the parse tree is the starting nonterminal of the grammar. Each node of the parse tree expands into one production of the grammar.

The final step of parsing is to do something useful with this parse tree. We’re going to translate it into a recursive data type. Recursive abstract data types are often used to represent an expression in a language, like HTML, or Markdown, or Java, or algebraic expressions. A recursive abstract data type that represents a language expression is called an *abstract syntax tree* (AST).

## Antlr Grammar

*Antlr* is a mature and widely-used parser generator for Java, and other languages as well.

Here's how the HTML grammar looks like an Antlr source file

```
grammar Html;

root : html EOF;
html : ( italic | normal ) *;
italic : '<i>' html '</i>';
normal : TEXT; 
TEXT : ~[<>]+;  /* represents a string of one or more characters that are not < or > 
```

Each Antlr rule consists of a name, followed by a colon, followed by its definition, terminated by a semicolon.

Nonterminals in Antlr have to be lowercase: `root` , `html` , `normal` , `italic` . Terminals are either quoted strings, like `'<i>'` , or capitalized names, like `EOF` and `TEXT`.
```
root : html EOF;
```
`root` is the starting non-terminal; entrypoint of our grammar.
`EOF` is a special terminal, defined by Antlr, that means the end of the input. It stands for end of file.

```
html : ( normal | italic ) *;
```
Same use of operators as in the `Grammars` chapter.

```
italic : '<i>' html '</i>';
normal : TEXT; 
TEXT : ~[<>]+;
```
`TEXT` is a terminal matching sequences of characters that are neither `<` nor `>` . Conventional regex uses `[^<>]` to represent all characters except `<` and `>` . Antlr uses a slightly different syntax – `~` means not , and it is put in front of the square brackets instead of inside them, so `~[<>]` matches any character except `<` and `>` .

In Antlr, terminals can also be defined using regular expressions, not just fixed strings:
```
IDENTIFIER : [a-z]+;
INTEGER : [0-9]+;
```

## Generating the Parser

We use the *IntegerExpression* grammar in the file `IntegerExpression.g4`. Antlr4 files end with `.g4`.The Antlr parser generator tool converts a grammar source file like IntegerExpression.g4 into Java classes that implement a parser. We do this from the terminal"

```bash
cd <root of project>
cd src/intexpr/parser
java -jar ../../../lib/antlr.jar IntegerExpression.g4
```

Note that you need to be in the directory where `IntegerExpression.g4` is, and you may need to reference your `jar` files from the home directory (I used `java -jar /home/flowingpurplecrane/6.005/lib/antlr.jar IntegerExpression.g4`).

Assuming no syntax errors in your grammar file, the parser generator will produce new Java source files in the current folder. Nothing will be printed in the terminal. The generated code is divided into several cooperating modules:

- the **lexer** takes a stream of characters as input, and produces a stream of terminals (Antlr calls them *tokens* ) as output, like `NUMBER` , `+` , and `(` . For `IntegerExpression.g4` , the generated lexer is called `IntegerExpressionLexer.java` .
- the **parser** takes the stream of terminals produced by the lexer and produces a parse tree. The generated parser is called `IntegerExpressionParser.java`
- the **tree walker** lets you write code that walks over the parse tree produced by the parser. The generated tree walker files are the interface `IntegerExpressionListener.java` , and an empty implementation of the interface, `IntegerExpressionBaseListener.java`

Antlr also generates two text files,` IntegerExpression.tokens` and `IntegerExpressionLexer.tokens` , that list the terminals that Antlr found in your grammar. These aren’t needed for a simple parser, but they’re needed when you include grammars inside other grammars.

Make sure that you:

- **Never edit the files generated by Antlr**. The right way to change your parser is to edit the grammar source file, `IntegerExpression.g4` , and then regenerate the Java classes.
- **Regenerate the files whenever you edit the grammar file**. Make sure you rerun the `java -jar ...` command whenever you change your .g4 file.
- **Refresh your project** in your IDE each time you regenerate your files

## Calling the Parser

Now we use the generated parser.

First we need to make a stream of characters to feed to the lexer:
```java
CharStream stream = new ANTLRInputStream("54+(2+89)");
```

Next, we create an instance of the lexer class that our grammar file generated, and pass it the character stream:
```java
IntegerExpressionLexer lexer = new IntegerExpressionLexer(stream);
TokenStream tokens = new CommonTokenStream(lexer);
```

The result is a stream of terminals, which we can then feed to the parser:
```java
IntegerExpressionParser parser = new IntegerExpressionParser(tokens);
```

To actually do the parsing, we call the parser on each nonterminal. The generated parser has one method for every nonterminal in our grammar, including `root()` , `sum()` , and `primitive()` . We want to call the nonterminal that represents the set of strings that we want to match – in this case, `root()` .
```java
ParseTree tree = parser.root();
```

For debugging, we can then print this tree out:
```java
System.err.println(tree.toStringTree(parser));
```

Or we can display it in a handy graphical form which pops up in an interactive window.
```java
Trees.inspect(tree, parser);
```

## Traversing the Parse Tree

We've used the parser to turn a stream of characters into a parse tree, which how the stream is converted into our grammar.

We traverse the parse tree with `ParseTreeWalker`, which is an Antlr class that walks over a parse tree using DFS (top-to-bottom,left-to-right). As it visits each node in the parse tree, it calls methods on a *listener* object that implements the `IntegerExpressionListener` interface.
- We call the `ParseTreeWalker`'s `walk` method with the listener object and our `ParseTree`

In `Main.java` we see the class `PrintEverything` that implements `IntegerExpressionListener` and basically prints a statement each time we enter and exit a node.

This `Listener` object allows us to do operations on each node as we traverse the tree, hence we can use this structure to create useful things like the addition calculator in `MakeIntegerExpression` subtype of `Listener`, or do differentiation in `ps3`!

```java
class PrintEverything implements IntegerExpressionListener {

    @Override public void enterRoot(IntegerExpressionParser.RootContext context) {
        System.err.println("entering root");
    }
    @Override public void exitRoot(IntegerExpressionParser.RootContext context) {
        System.err.println("exiting root");
    }

    ...

    @Override public void visitTerminal(TerminalNode terminal) {
        System.err.println("terminal " + terminal.getText());            
    }

    // don't need these here, so just make them empty implementations
    @Override public void enterEveryRule(ParserRuleContext context) { }
    @Override public void exitEveryRule(ParserRuleContext context) { }
    @Override public void visitErrorNode(ErrorNode node) { }         
}
```

- Notice that every nonterminal `N` in the grammar has corresponding `enterN()` and `exitN()` methods in the listener interface, which are called when the tree walk enters and exits a parse tree node for nonterminal `N` , respectively.
- `visitTerminal()` is called when the walk reaches a leaf of the parse tree
- Each of these methods has a parameter (`context`,`terminal` etc) that provides information about the node that the walk is currently visiting.
- The interface requires us to implement these methods, but we leave the method bodies empty:
  - `enterEveryRule()` and `exitEveryRule()` are called on entering and exiting any nonterminal node, in case we want some generic behavior.
  - `visitErrorNode()` is called if the input contained a syntax error that produced an error node in the parse tree. We didn't implement this, so a syntax error just throws an exception

When we actually walk the parse tree with this listener, we see the following output in the terminal:
```
entering root
entering sum
entering primitive
terminal 54
exiting primitive
terminal +
entering primitive
terminal (
entering sum
entering primitive
terminal 2
exiting primitive
terminal +
entering primitive
terminal 89
exiting primitive
exiting sum
terminal )
exiting primitive
exiting sum
terminal <EOF>
exiting root
```

<img src=image.png width=200>

This is clearly entering and exiting the nodes with **post-order DFS**!

## Constructing an Abstract Syntax Tree

We need to convert the parse tree to a recursive data type. Here the datatype definition of this recursive datatype:

```
IntegerExpression = Number(n:int) + Plus(left:IntegerExpression, right:IntegerExpression)
```
- Abstract Syntax Tree
  - The `IntegerExpression` value captures its grouping and current integer value, while omitting details of the sequence of characters that created this object
- Concrete Syntax Tree
  - The parse tree is a concrete syntax tree. It contains way more details and is a concrete representation of the numbers, like `2+2` or `0002+0002`
  - These trees would all correspond to the same abtract `IntegerExpression` value of `Plus(Number(2)+Number(2))`

Now we create a listener that constructs a tree made of `IntegerExpression` objects while it’s walking over the parse tree. Each parse tree node will correspond to a `IntegerExpression` variant: `sum` nodes will create `Plus` objects, and `primitive` nodes (that matched the `NUMBER` terminal) will create `Number` objects.
- Some `primitive` nodes aare `(` and `)`, we ignore these
- Whenever the walker exits the node, this means we have walked over the entire subtree of the node (nature of post-order DFS). We then evaluate the expression.

Refer to `MakeIntegerExpression` class in `Main.java`.